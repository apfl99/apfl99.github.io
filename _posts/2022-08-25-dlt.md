---
title: "분산원장"
categories:
 - BEB
tags: [분산 데이터베이스, 분산원장, 세그윗, 머클트리] 
toc: true
author_profile: true #profile sidebar 감추기
# sidebar:
#     nav: "docs" # 목차 사이드바
search: true #검색 피하기

---



# 분산 데이터베이스와 분산 원장

-----



## 분산 데이터베이스

분산 데이터베이스란 하나의 데이터베이스 관리 시스템(DBMS, Database Management System)으로, 여러 CPU에 연결된 저장장치들을 제어하는 형태의 데이터베이스이다.

물리적으로는 여러 위치에 분산 저장하고 흩어져 있지만, 논리적으로는 하나인 것처럼 활용 된다.

분산 데이터베이스는 6가지의 투명성을 목표로 한다.

| 종류     | 내용                                                  | 특징                     |
| -------- | ----------------------------------------------------- | ------------------------ |
| 병행     | 다수의 트랜잭션 수행 시 결과가 일관성 유지            | 자원처리 양 및 속도 개선 |
| 장애     | 장애 발생이 원자성 유지                               | 데이터 일관성            |
| 지역사상 | 개별 지역의 물리적 이름과 관계없이 접근 가능          | 확장성 확보              |
| 위치     | 데이터를 물리적 저장 위치가 아닌 논리적 입장에서 접근 | 생산성, 활용성 강화      |
| 중복     | 데이터를 지역별로 중복 저장하여도 데이터 처리 가능    | 병목현상 해소            |
| 분할     | 물리적 구조가 여러 단편으로 분할 저장되어 논리적 사용 | 성능향상                 |



### 분산 데이터베이스의 대표적 기술

---



#### 일반적인 데이터베이스

![img1](../../images/2022-08-25-dlt/img1.png)

{: .align-center}

일반적인 데이터 베이스는 데이터 요청을 처리하는 서버, 실제 데이터를 저장하는 스토리지가 각 1개씩 존재한다.



#### 클러스터링

클러스터링의 경우 만약 서버가 다운되는 것에 대한 우려로 등장하였으며, 이에 따라 서버를 하나 더 마련하는 데, 두 개의 서버를 가동하는 Active-Active 방식과 하나의 서버를 가동하고 다른 하나는 장애 발생시 가동하도록 대기하는 Active-Standby 방식이 있다.

- Active - Active

![img2](../../images/2022-08-25-dlt/img2.png)

{: .align-center}

- Active - Standby

![img3](../../images/2022-08-25-dlt/img3.png)

{: .align-center}



장점

- 서버 장애 발생 시 서비스에 지장 X
- 서버가 여러 대이기 때문에 성능 유리

단점

- 데이터베이스는 1개이기에 병목 현상 발생 우려
- 서버 운영 비



#### 레플리케이션

클러스터링이 서버에 대한 우려로 생겨났다면, 레플리케이션은 데이터에 대한 우려로 생겨났으며, 이에 데이터 스토리지 또한 하나 더 마련한다. 레플리케이션 방식은 하나 더 마련한 스토리지를 백업 용도로 쓰느냐 아니면 Read만 가능한 스토리지로 부하를 분산 시키느냐 에 따라 단순 백업 방식과 부하 분산 방식으로 나뉜다.

- 단순 백업 방식

![img4](../../images/2022-08-25-dlt/img4.png)

{: .align-center}

- 부하 분산 방식

![img5](../../images/2022-08-25-dlt/img5.png)

{: .align-center}



장점

- 부하 분산의 경우 데이터베이스의 Read 성능을 높일 수 있다.
- 비동기 방식으로 운영되어 지연시간이 거의 없다.

단점

- 각 노드 간의 데이터 동기화 보장이 어렵다.
- Master 노드가 다운되면 복구 및 대처가 어렵다.



#### 샤딩

샤딩은 데이터 양과 관련한 데이터의 조회 속도에 대한 우려로 생겨났으며, 여기서 고려해야 할 점은

1. 데이터를 어떻게 잘 분산 시킬 것인가

2. 분산된 데이터베이스에서 어떻게 데이터를 읽을 것인가

이다.  이에 띠라 나눠진 Shard(분산된 데이터베이스)에 접근하는 키인 Shard Key 결정 방식이 나뉘며 종류는 해시 샤딩, 다이나믹 샤딩, 엔티티 그룹 샤딩이 있다.

- 해시 샤딩 : Shard Key를 결정하는 데 해쉬 함수를 사용하는 방법

![img6](../../images/2022-08-25-dlt/img6.png)

{: .align-center}

장점

- 샤드 수만큼 해싱하면 되기 때문에 구현이 간단하다.

단점

- 샤드가 늘어나면서 해시 함수가 달라져야 하기에 확장성이 떨어진다.
- 단순히 해시함수를 통해 나누기에 각 샤드별 공간에 대한 효율을 고려하지 않는다.



---

- 다이나믹 샤딩 : 해시 샤딩의 확장성 문제를 해결하기 위해 Locator service를 Shard Key를 등록하는 방법

![img7](../../images/2022-08-25-dlt/img7.png)

{: .align-center}

장점

- 샤드가 증가하면 Locator service에 추가해주면 되기 때문에 확장성이 용이하다.

단점

- 데이터를 재배치 시 Locator service 동기화가 요구된다.
- Locator service에 의존적이라 해당 테이블에 문제가 생기면 DB에도 문제가 생긴다.



---

- 엔티티 그룹 샤딩 : 앞서 나온 두 샤딩 방식은 비관계형 데이터베이스에 적합하고 엔티티 그룹의 샤딩은 관계형 데이터베이스에 적합하다. 관계에 대한 엔티티를 같은 샤드 내에 존재하도록 구성한 방법

![img8](../../images/2022-08-25-dlt/img8.png)

{: .align-center}

장점

- 단일 샤드 내에서 쿼리가 효율적이다.
- 단일 샤드 내에서 강한 응집도를 가진다.

단점

- 다른 샤드의 엔티티와 연관이 되는 쿼리의 경우 오히려 실행 효율이 감소한다.



### 분산 데이터베이스의 장단점

----

분산 데이터베이스는 논리적으로는 하나의 데이터베이스를 사용하는 것처럼 하되, 실제로는 분산된 형태이기 때문에 구현 방법이 복잡하며, 각 트랜잭션은 다중 데이터베이스에 걸쳐 일관성을 보장해야 하기 때문에 트랜잭션은 일반적으로 여러 하위 트랜잭션으로 나뉘어 개별 서브 트랜잭션이 하나의 데이터베이스에 대응한다.

장점

- 조직 구조를 반영할 수 있다.
- 나눠진 데이터베이스에 대한 제어가 용이하다.
- 데이터가 한 곳에 있는 것보다 안전하다.
- 부하 분산이 가능하기 때문에 성능이 좋다.
- 고성능 컴퓨터보다 소형 컴퓨터 네트워킹이 저렴하다.
- 다른 모듈에 영향을 주지 않고, 개별 시스템을 CRUD할 수 있다.
- 장애 발생 시 전체 기능은 손상되지 않으며, 모든 거래는 ACID 특성에 따른다.



단점

- 구현 방법이 복잡하다.
- 시스템 규모와 복잡성이 증가함에 따라 관리 비용도 증가한다.
- 각 노드와 네트워크의 보안을 확보하지 않으면 전체 보안도 위험해진다.
- 무결성을 위한 상당한 네트워크 자원을 필요로 한다.
- 표준이 부족하다.
- 데이터베이스 설계가 복잡하다.
- 추가 소프트웨어를 필요로 한다.
- 운영 체제가 분산 컴퓨팅을 지원해야 한다.
- 동시성 제어가 중요하다.



### 분산 데이터베이스와 블록체인의 차이점

-----

가장 큰 차이점은

1. 블록체인은 악의적인 사용자를 전제하고 만들어진 시스템(합의 알고리즘)
2. 운영 주체가 사라져도 시스템 유지 가능(거버넌스)

이다.



## 분산원장



### 중앙집중형 원장

---

중앙 집중형 원장은 분산원장에 반대되는 개념으로 중앙 기관에서 원장을 관리하여 자산을 직접 보관하는 것에 비해 비용을 절감하고 소유권을 명확히 할 수 있으나, 중앙 기관 및 관리 기관에만 권한과 책임이 집중되기 때문에 신뢰에 의존하고, 운영 비용이 많이 발생하여 수수료가 높으며, 규제 및 감독에 따라 사용자를 제한한다.



### 분산원장

---

분산원장은 원장을 중앙 기관이 아닌 P2P 네트워크에 분산하여 참가자가 공동으로 저장하고 기록하며, 각 참가자(노드)가 데이터베이스이기 때문에 분산 데이터베이스의 한 종류라고 할 수 있다. 이러한 방식은 효율성, 보안성, 시스템 안정성, 투명성의 장점을 가질 수 있으나, 신뢰를 담보해줄 기관이 존재하지 않기 때문에 시스템 자체에서 신뢰를 형성하는 메커니즘 설계가 필요하다. 따라서 신뢰를 형성하는 메커니즘(합의 알고리즘)을 가진 블록체인과는 조금 차이가 있다.



# 세그윗(SegWit)

-----

세그윗이란 블록체인의 합의에 도달하여 거래 기록이 장부에 기록되는 데 걸리는 시간을 나타내는 속도와 트래픽에 대한 서비스 연속성이 보장되는 성질인 확장성을 개선하기 위한

1. 블록의 용량 증대
2. 블록체인 내 기술 도입 : 샤딩 등
3. 블록쳉니 외부와 연계
4. 합의 알고리즘 재설계

의 4가지 방법 중 블록의 용량 증대에 대한 방법으로 비트코인의 블록에서 디지털 서명 부분을 Off-Chain에서 작동하게끔 분리함으로써 블록당 저장 용량을 늘리는 소프트웨어 업그레이드(포크)를 말한다.

기존의 비트코인의 경우, 블록 구조 중 75%는 디지털 서명 데이터였기 때문에 세그윗을 통해 블록저장 공간을 늘려 기존 시스템에는 영향을 주지 않으면서(단순히 블록의 크기를 늘리면 더 많은 해시파워를 요구하게 되면서 소수의 노드들이 장악할 수 있다. 또한 소프트 포크이기 때문에 모든 노드에서 사용 가능하다.) 한 개 블록에 더 많은 거래 정보를 담고 처리할 수 있었으며, 세그윗이 서명을 따로 분리함으로써, 비트코인 거래 ID인 TXID를 통해 동일한 거래를 여러 개 만드는 행위를 방지할 수 있게 되어

- 거래 속도의 확장성
- 버전 호환
- 거래 가변성 문제

를 해결하였다.



# 머클트리

----

머클트리란 여러 데이터에 대해 단계적으로 해시함수를 적용하여 하나의 해시값을 나타내는 데이터 구조로, 블록체인에서 데이터 위변조를 방지하고, 데이터 무결성을 보장하는 데 사용된다.



## 머클 트리 동작 방식

![img9](../../images/2022-08-25-dlt/img9.png)

{: .align-center}

위 그림과 같이 머클 트리는 제일 말단 데이터로부터 트리 구조에서 루트로 가며 해쉬하는 구조로 여기서 최종 값인 머클 루트는 모든 데이터를 모아 해싱한 값이다. 해싱 특성상, 입력 데이터가 조금만 바뀌어도 동일한 출력값을 가지지 않기 때문에(충돌 저항성)  결국 제일 말단에 있는 데이터 하나만 바뀌어도 머클 루트가 크게 변화하게 되고, 이러한 특성을 통해 데이터 무결성을 보장할 수 있다.



## 블록체인에서의 머클트리(비트코인)

![img10](../../images/2022-08-25-dlt/img10.png)

{: .align-center}



위 그림과 같이 블록체인에서는 트랜잭션 데이터에 머클트리를 적용하여 헤더에 머클루트 값이 포함된다. 이를 통해 블록이 담은 트랜잭션이 하나라도 바뀌게 되면 머클 루트 값이 변화하게 되고

![img11](../../images/2022-08-25-dlt/img11.png)

{: .align-center}

블록체인에서는 헤더를 해쉬한 값이 블록 해쉬값이 되고, 블록 해쉬값은 다음 블록의 헤더에 저장되기 때문에 트랜잭션 데이터 하나라도 위변조하려면 해당 블록 이후의 연결된 블록을 모두 수정해야 한다. 이러한 특성 때문에 위변조를 하기 매우 어렵다.



## 블록체인에서의 머클 트리 : 머클 패트리샤 트리(이더리움)

우선 트랜잭션을 통해 데이터를 추가, 삭제하는 비트코인과는 달리, 이더리움은 데이터의 값을 수정하는 상태 전이가 이루어진다. 따라서 비트코인의 경우는 데이터가 모두 새로 만들어 지기 때문에 머클 트리와 같은 방식이 유효하지만, 이더리움의 경우, 기존의 Key에 대한 Value를 수정하기 때문에

![img13](../../images/2022-08-25-dlt/img13.png)

{: .align-center}

위 그림과 같이 키가 일반적으로 문자열인 동작 집합 또는 연관 배열을 저장하는 데 사용되는 트라이라는 것을 활용하여 공통된 부분을 공유하는 것이 공간적인 측면에서 효율적이며, 이더리움의 모든 블록 헤더에는 트랜잭션, 영수증, 상태에 대한 세 가지 트리로 나타낸다.

![img12](../../images/2022-08-25-dlt/img12.png)

{: .align-center}

따라서 위 트리와 같은 구조를 보인다. 하지만 위 트리와 같은 구조는 이더리움의 상태가 자주 수정되고, 삽입 및 삭제 또한 자주 이루어지는 특성상 전체 트리를 다시 계산하지 않고, 앞에 말한 작업을 한 후, 새 트리 루트를 빠르게 계산할 수 있는 구조가 필요하다. 따라서 이에 이더리움에서는 

![img14](../../images/2022-08-25-dlt/img14.png)

{: .align-center}

위 그림과 같이 Branch Node, Extension Node, Leaf Node를 통해 구현하였으며, 각 노드의 역할은 다음과 같다.

- Branch Node
  - 앞의 16칸은 자식노드를 가르키는 값 + 뒤에 1칸은 자신의 값
  - 17개의 값을 저장하기 때문에 2개의 하위 노드를 갖는 머클 트리보다 효율적
- Extension Node
  - [Key, Value] 구조로 되어 있으며, Key에는 공통으로 묶여진 값, Value에는 branch Node를 해쉬한 값
  - 경로 계산 용이
- Leaf Node
  - [Key, Value] 구조로 되어 있으며, 각각의 거래 정보를 구성한다.





<div class="notice">
  <p>본 포스팅은 코드스테이츠 BEB 과정을 수강하며 작성한 글입니다.</p>
  <a>https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/</a>
  <br>
  <a>https://ethereum.stackexchange.com/questions/6415/eli5-how-does-a-merkle-patricia-trie-tree-work/</a>
  <br>
  <a>https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/</a>
  <br>
  <a>https://medium.com/ethereum-core-research/%EB%A8%B8%ED%81%B4-%ED%8C%A8%ED%8A%B8%EB%A6%AC%EC%83%A4-%ED%8A%B8%EB%A6%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-2cb8a2617324</a>
  <br>
</div>