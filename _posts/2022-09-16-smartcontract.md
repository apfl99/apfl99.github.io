---
title: "스마트 컨트랙트"
categories:
 - BEB
tags: [] 
toc: true
author_profile: true #profile sidebar 감추기
# sidebar:
#     nav: "docs" # 목차 사이드바
search: true #검색 피하기



---



# 스마트 컨트랙트

---

#### 특징

- 스마트 컨트랙트는 중개인의 존재 여부와 상관없이, 조건이 충족된다면 계약이 이행되고, 조건이 충족되지 않는다면 이행되지 않는다
  - 이러한 특성은 블록체인의 탈중앙성과 적합하고, 중개인이 없기 때문에 거래 수수료를 절감할 수 있다.

- 블록체인의 특성상 배포 및 자동화는 누구든지 가능하며, 검증도 제약없이 자유로우며 변경이 불가하고 거래 내역이 투명하다.

- 스마트 컨트랙트는 코드에 의해 실행되기 때문에 코드에 따라 계약이 실행됨을 보장하는 결정론적인 상태이다.



#### 장점

- 보안
  - 스마트 컨트랙트는 블록체인 위에서 실행되기 때문에, 모든 노드가 스마트 컨트랙트 내용과 이행 결과를 가짐에 따라 계약에 대한 중앙화된 공격 지점이 없고, 계약 내용이나 결과를 변조할 위협이 없다.
- 신뢰성
  - 스마트 컨트랙트 로직이 조건에 부합해 계약이 이행되면 블록체인 네트워크에 있는 노드들에 의해 여러 번 수행되고 검증되기 때문에, 위변조가 매우 어렵고 정확도가 높다.
- 공평함
  - 블록체인으로 계약 조건을 공유하고 강제하기 때문에 특정 이득을 취하는 중개자가 없다.
- 효율성
  - 계약 이행의 자동화로 계약의 프로세스 검증이 필요 없다.



#### 한계점

- 컨트랙트 배포 이후, 컨트랙트가 보안적 취약점을 가진다는 등 코드의 문제가 있더라도 수정할 수 없다.
- 컨트랙트 코드는 블록체인 안에서 동작하기 때문에 외부 데이터를 스스로 취득할 수 없다.



## 비트코인에서의 스마트 컨트랙트

비트코인에서는 UTXO로 코인을 관리한다. 여기서 UTXO가 동작하는 과정이 스마트 컨트랙트로 이루어진다.



### UTXO 동작 원리

---



#### 비트코인 트랜잭션 구조

![i1](../../images/2022-09-16-smartcontract/i1.png)

{: .align-center}

- 트랜잭션 버전(Transaction Version) : 트랜잭션 유형을 지정하는 버전 번호로, 노드가 트랜잭션을 읽을 때, 버전 번호를 확인하고 트랜잭션을 어떻게 읽어야 하는지 파악한다.

- 잠금 시간(Lock Time) : 잠금 시간으로, 트랜잭션은 잠금 시간이 지나야 포함할 수 있다.

- 입력(Input)과 출력(Output)

  - 입력 : 입력은 포인터(Pointer)와 해제키(Unlocking)가 들어있으며, 여기서 포인터는 이전 트랜잭션 출력을 가리키고, 키는 포인터로 가리키고 있는 이전 출력을 해제하는 데 사용한다.
  - 출력 : 출력은 잠금(Lock)과 값(Value)로 구성되어 있으며, 입력에서 잠금을 해제할 수 있는 키가 존재하며, 값은 출력 내에 잠겨 있는 사토시의 양을 의미한다.



#### UTXO

트랜잭션 구조를 보면 결국 입력과 출력으로, 출력에는 자산이 잠겨있고, 입력으로 출력을 해제하여 값을 꺼내, 사용한 후, 새로운 출력에 자산을 담는다. 여기서 입력에 의해 해제되지 않은 트랜잭션을 UTXO라고 하며, 말 그대로 미사용 트랜잭션 출력값이다.

이를 그림으로 나타내면 다음과 같다.

![i2](../../images/2022-09-16-smartcontract/i2.jpeg)

{: .align-center}

이러한 UTXO 모델은 확장성이 좋고, 트랜잭션 로직이 단순하기 때문에 병렬적으로 검증이 가능하다.



### 비트코인 스크립트

---

비트코인에서는 스크립트라는 스크립터 언어를 사용해 스마트 컨트랙트를 구현한다. 스크립트에서 사용하는 연산들은 Opcode에 해당하며, 스크립트는 트랜잭션에 연결되어 있어 네트워크의 모든 노드는 트랜잭션을 받을 때마다 자신의 로컬 컴퓨터에서 트랜잭션에 연결된 스크립트를 실행하여 이를 통해 비트코인 송금이 이루어진다.

결국 스크립트는 입출력에 의한 UTXO 잠금, 해제 메커니즘이다.



#### 입출력 구조

![i3](../../images/2022-09-16-smartcontract/i3.png)

{: .align-center}

- Input Structure
  - Prev. Tx ID, TxIndex : 해제하고자 하는 이전 출력을 가리키는 포인터
  - ScriptSig : 포인터가 가리키는 출력을 해제하는 키
- Output Structure
  - ScriptPubkey : 잠금, ScriptPubKey의 소유자만이 잠금을 해제하는 키인 ScriptSig를 생성할 수 있다.
  - Amount : 잠긴 비트코인의 양(단위 : 사토시)



#### 스크립트 동작 원리

스크립트는 스택 기반 튜링 불완전 언어이다. 즉, 스택 구조로 동작하며, 불완전 튜링이기 때문에 간단한 연산만 가능하다.(반복문 등은 불가능)

스크립트는 

- Opcode : 덧셈, 뺄셈, 곱셈과 같은 연산 작업
- 데이터 : OP_CODE가 아닌 모든 데이터로, 스택에 들어가게 된다.

의 두 종류 객체를 가지며, 스크립트는 이 두 종류의 객체를 일렬로 늘어놓은 것이다.

동작은 포인터가 일렬로 늘어진 Opcode와 데이터를 순서대로 가리키며, 포인터가 데이터를 가리킬 경우, 스택에 데이터를 넣고 opcode를 가르킬 경우 스택에서 데이터를 꺼내온다(FILO).

따라서 노드는 새로운 트랜잭션에 대해서 Script와 ScriptPubkey 필드를 추출하여 ScriptSig +ScriptPubKey의 스크립트 형태를 얻게 되며 해당 스크립트와 빈 스택 하나를 사용해 스크립트를 실행하고 실행 결과, 최상위 스택 요소가 1일 경우 트랜잭션이 유효하다 판단하고 주변 노드에게 전파하고 유효하지 않은 경우 전파하지 않는다.



#### 비트코인 스크립트 : Pay To PubKey(P2PK)

P2PK는 가장 간단한 종류의 스크립트로, 

![i4](../../images/2022-09-16-smartcontract/i4.png)

{: .align-center}

위와 같이 해제 키를 정의하는 데이터(입력)인 ScriptSig와 잠금을 정의하는 데이터(출력)인 ScriptPubkey, Opcode로 구성되어 있다. 동작은 다음과 같다.

1. 빈 스택에서 포인터가 서명(signature)를 가리킨다.
2. 서명(signature)은 데이터이므로 스택에 들어간다. 포인터는 그 다음 요소인 공개 키(public key)를 가리킨다.
3. 공개키는 데이터이므로 스택에 넣는다. 포인터는 그 다음 요소인 OP_CHECKSIG를 가리킨다.
4. OP_CHECKSIG는 스택에서 공개키와 서명을 꺼내고 ECDSA 알고리즘을 사용해 서명을 검증한다.
   - 성공 시, 스택에 1을 넣고, 실패 시 스택에 0을 넣는다.
5. 스택의 최종값이 1일 경우 트랜잭션 검증이 완료되고 UTXO가 해제되고, 0일 경우 여전히 잠금 상태이다.

그러나 해당 스크립트의 경우 수신자의 public key가 그대로 노출되기 때문에 보안에 취약하며, 오늘날에는 사용되지 않는다.



#### PayToPubKeyHash(P2PKH)

P2PKH는 P2PK에서 수신자의 공개 키 공개 문제를 개선한 스크립트로, ScriptPubkey가 공개키의 해시값을 갖는다.

![i6](../../images/2022-09-16-smartcontract/i6.png)

{: .align-center}

위의 스크립트에서는 ScriptSig에 서명과 공개키가 존재하고, ScriptPubKey에는 여러 개의 Opcode와 수신자의 공개키를 해싱한 Hash 1 객체가 존재한다. 동작은 다음과 같다.

1. 빈 스택에서 포인터는 서명(signature)를 가리킨다.
2. 서명(signature)는 데이터이기 때문에 스택에 들어가고, 포인터는 다음 요소인 공개키(public key)를 가리킨다.
3. 공개키(public key)도 데이터이기 때문에 스택에 들어가고, 포인터는 다음 요소인 OP_DUP를 가리킨다.
4. OP_DUP는 스택 최상단 요소를 복사하는 Opcode로, 스택에 공개키(public key)가 하나 더 들어가고, 포인터는 다음 요소인 OP_HASH160을 가리킨다.
5. OP_HASH160은 스택 최상단 요소를 해싱하는 Opcode로, 최상단에 있는 공개 키가 해싱되어 Hash2로 들어가고, 포인터는 다음 요소인 Hash 1을 가리킨다.
6. Hash1은 데이터이기 때문에 스택에 들어가고, 포인터는 다음 요소인 OP_EQUALVERIFY를 가리킨다.
7. OP_EQUALVERIFY는 스택에 있는 두 요소가 같은지 확인하는 Opcode로 만약 두 요소가 같다면 해당 요소 두 개를 제거하고, 다르다면 실행에 실패한다. 즉 ScirptSig(입력)에 올바른 공개 키가 있었다면 ScriptPubkey에 들어있던 Hash 1과 공개키를 해싱한 값인 Hash 2가 동일하고, 스택에서 제거된다. 이후 포인터는 다음 요소인 OP_CHECKSIG를 가리킨다.
8. OP_CHECKSIG 이후로는 Pay To PubKey(P2PK)와 동일하게 동작한다.



### 비트코인 스마트 컨트랙트의 한계와 대안

---



#### 라이트닝 네트워크(Lightning Network)

[라이트닝 네트워크]()





#### 루트스탁(Rootstock, RSK)

[루트스탁]()



#### 탭루트(TapRoot)

[탭루트](https://apfl99.github.io/beb/dlt2/#tap-root)




<div class="notice">
  <p>본 포스팅은 코드스테이츠 BEB 과정을 수강하며 작성한 글입니다.</p>
  <h5>Reference</h5>
  <a></a>
  <br>
</div>